---
id: state-management
title: State Management
slug: /state
---

# ðŸ—„ State Management with React Query

## ðŸ“Œ Why We Chose React Query

In the **Crypto Price Tracker**, we use **React Query** instead of traditional state management solutions like Redux or Zustand.  
ðŸ“Œ React Query helps **fetch, cache, and synchronize server data** with the UI efficiently.

### **ðŸ”¹ Benefits of React Query**
âœ… **Automatic Caching** â†’ Prevents unnecessary API calls  
âœ… **Background Fetching** â†’ Updates data without UI freezing  
âœ… **Error Handling** â†’ Handles API failures gracefully  
âœ… **Less Boilerplate** â†’ No need for manual state handling  

---

## ðŸ”„ **Fetching & Caching Crypto Prices with React Query**
We manage API calls inside `dashboard.tsx` using `useQuery`.

```tsx
const { data, error, isLoading, refetch } = useQuery<CryptoData, Error>({
  queryKey: ["cryptoPrices"],
  queryFn: fetchCryptoPrices,
  refetchOnWindowFocus: false,
  staleTime: 60000, // Cache data for 1 minute
  gcTime: 300000,   // Remove unused data after 5 minutes
});

```

## Explanation
âœ… queryKey: ["cryptoPrices"] â†’ Identifies this specific query

âœ… queryFn: fetchCryptoPrices â†’ Calls API when needed

âœ… refetchOnWindowFocus: false â†’ Prevents automatic refetching when users switch tabs

âœ… staleTime: 60000 â†’ Keeps data fresh for 1 minute before allowing refetch

âœ… gcTime: 300000 â†’ Removes unused data after 5 minutes to free memory

ðŸ“Œ With React Query, we ensure efficient state updates while reducing API load!

## ðŸ” Handling Search Filtering with useState
While React Query manages server-side data, we use useState for client-side filtering.

```tsx

const [search, setSearch] = useState("");

const filteredData = data
  ? Object.entries(data).filter(([key]) =>
      key.toLowerCase().includes(search.toLowerCase())
    )
  : [];

```

## Explanation
âœ… useState("") â†’ Stores the search input

âœ… .filter(([key]) => key.toLowerCase().includes(search.toLowerCase())) - Converts crypto names to lowercase + Matches search input dynamically

âœ… Updates the displayed list without making extra API requests

ðŸ“Œ With this approach, the UI remains highly responsive while keeping API usage efficient.

## Manual Data Refresh

To improve UX, we disabled automatic refetching and added a manual refresh button.

```tsx

const [isRefreshing, setIsRefreshing] = useState(false);

const handleRefresh = async () => {
  setIsRefreshing(true);
  await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5s
  await refetch(); // Fetch new data
  setIsRefreshing(false);
};

```
## Explanation
âœ… setIsRefreshing(true) â†’ Activates the loading state
âœ… setTimeout(resolve, 5000) â†’ Adds a 5-second delay
âœ… refetch() â†’ Fetches fresh API data
âœ… setIsRefreshing(false) â†’ Removes loading state

ðŸ“Œ This ensures that users donâ€™t spam API requests while keeping data fresh.

